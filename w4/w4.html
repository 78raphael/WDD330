<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../css/main.css">
    <title>Week X</title>
  </head>
  <body>
    <nav>
      <ul id="navigation">
        <li>
          <a href="#" id="menu">Menu</a>
        </li>
        <li>
          <a href="../index.html">Home</a>
        </li>
        <li>
          <a href="../w1/w1.html">Week 1</a>
        </li>
        <li>
          <a href="../w2/w2.html">Week 2</a>
        </li>
        <li>
          <a href="../w3/w3.html">Week 3</a>
        </li>
        <!-- <li>
          <a href="../w5/w5.html">Week 5</a>
        </li> -->
        <!-- <li>
          <a href="../w6/w6.html">Week 6: Midterm Checking</a>
        </li> -->
        <!-- <li>
          <a href="../w7/w7.html">Week 7</a>
        </li> -->
        <!-- <li>
          <a href="../w8/w8.html">Week 8</a>
        </li> -->
        <!-- <li>
          <a href="../w9/w9.html">Week 9</a>
        </li> -->
        <!-- <li>
          <a href="../w10/w10.html">Week 10</a>
        </li> -->
        <!-- <li>
          <a href="../w11/w11.html">Week 11</a>
        </li> -->
        <!-- <li>
          <a href="../w12/w12.html">Week 12</a>
        </li> -->
        <!-- <li>
          <a href="../w13/w13.html">Week 13</a>
        </li> -->
        <!-- <li>
          <a href="../w14/w14.html">Week 14</a>
        </li> -->
      </ul>
    </nav>
    <div class="main-container">
    <header></header>
    <div class="container">
      <h2>Week 4</h2>
      <section class="notes odd">
        <h2>Notes</h2>
        <hr>
        <p class="title">Chapter 8: Forms</p>

        <p>Forms
          <ul>
            <li>A form object also has a method called elements that returns an HTML collection of all the elements contained in the form</li>
            <li>const [input,button] = form.elements;</li>
            <li>The form.submit() method will submit the form automatically</li>
            <li>The form.reset() method will reset all the form controls back to their initial values specified in the HTML</li>
          </ul>
        </p>
        <p>Form Events
          <ul>
            <li>The focus event occurs when an element is focused on</li>
            <li>The blur event occurs when the user moves the focus away from the form element</li>
            <li>The change event occurs when the user moves the focus away from the form element after changing it</li>
          </ul>
        </p>
        <p>
          Form Validation
          <ul>
            <li>Form validation is the process of checking whether a user has entered the information into a form correctly</li>
            <li>It is advisable to use both client-side and server-side validation. JavaScript should not be relied upon to validate any data before it’s saved to a database. This is because it’s possible for a user to modify the JavaScript code and bypass the validation rules</li>
            <li>JavaScript validation should be used to enhance the user experience when filling in a form by giving feedback about any errors before it’s submitted</li>
          </ul>
        </p>
      </section>

      <section class="notes even">
        <h2>Notes</h2>
        <hr>
        <p class="title">Chapter 12: Object Oriented Programming</p>
          
        <p>
          <ul>
            <li>Object-oriented programming (OOP for short) is a style of programming that involves separating the code into objects that have properties and methods. This approach has the benefit of keeping related pieces of code encapsulated in objects that maintain state throughout the life of the program</li>
            <li>There are three main concepts in OOP: 1) encapsulation, 2) polymorphism and 3) inheritance</li>
          </ul>
        </p>
        <p>ENCAPSULATION
          <ul>
            <li>This demonstrates the concept of encapsulation: the inner workings are kept hidden inside the object and only the essential functionalities are exposed to the end user</li>
            <li>In OOP, this involves keeping all the programming logic inside an object and making methods available to implement the functionality, without the outside world needing to know how it’s done.</li>
          </ul>
        </p>
        <p>POLYMORPHISM
          <ul>
            <li>The concept of polymorphism: the same process can be used for different objects</li>
            <li>In OOP, this means various objects can share the same method, but also have the ability to override shared methods with a more specific implementation</li>
          </ul>
        </p>
        <p>INHERITANCE
          <ul>
            <li>The concept of inheritance: taking the features of one object then adding some new features</li>
            <li>In OOP, this means we can take an object that already exists and inherit all its properties and methods. We can then improve on its functionality by adding new properties and methods.</li>
          </ul>
        </p>
        <p>
          <ul>
            <li>The concept of using actual objects as the blueprint for creating more objects. This is known as a prototype-based language</li>
            <li>When Parentheses Aren’t Required: The parentheses are not required when instantiating a new object using a constructor function</li>
            <li>The parentheses are required, however, if any default arguments need to be provided.</li>
            <li>Capitalizing Constructor Functions: By convention, the names of constructor functions or class declarations are capitalized</li>
            <li>The ES6 class declarations are preferable to the constructor function syntax because they are more succinct, easier to read and all code in a class definition is implicitly in strict mode, so doesn't need the 'use strict' statement. Using ES6 class declarations also avoids a number of pitfalls associated with constructor functions.</li>
            <li>An error is thrown when trying to call a class constructor without using the new operator, whereas doing the same thing with a constructor function can cause a lot of problems that are hard to track down</li>
          </ul>
        </p>
        <p>Prototypal Inheritance
          <ul>
            <li>JavaScript uses a prototypal inheritance model. This means that every class has a prototype property that is shared by every instance of the class</li>
            <li>Any properties or methods of a class’s prototype can be accessed by every object instantiated by that class</li>
          </ul>
        </p>
        <p>OVERWRITING PROTOTYPE PROPERTIES
          <ul>
            <li>An object instance can overwrite any properties or methods inherited from its prototype by simply assigning a new value to them</li>
            <li>Any own properties will take precedence over the same prototype property when used in methods</li>
            <li>The prototype can be used to add any new properties and methods after the class has been declared. It should be used to define any properties that will remain the same for every instance of the class</li>
            <li>A golden rule to remember is: Never use arrays or objects as a default value in prototype</li>
            <li>
              <ol>
                <li>Create a class declaration that deals with any initialization, shared properties and methods.</li>
                <li>Any extra methods and properties that need to be augmented to the class declaration after it’s been defined can be added to the prototype. These will be added to all instances, even those that have already been created.</li>
                <li>Add any properties or methods that are individual to a particular instance can be augmented using assignment to that object.</li>
                <li>Be careful when overwriting the prototype completely ― the constructor class needs to be reset.</li>
              </ol>
            </li>
          </ul>
        </p>
        <hr>
        Inheritance
        <p>The Object Constructor
          <ul>
            <li>When an object calls a method, the JavaScript engine will check to see if the object has that method. If it doesn’t, it will check if the object’s prototype has the method</li>
            <li>Inside the child class declaration, the keyword super refers to the parent class, and can be used to access any properties and call any methods of the parent class</li>
          </ul>
        </p>
        <hr>
        Polymorphism
        <p>
          <ul>
            <li>The concept of polymorphism means that different objects can have the same method, but implement it in different ways</li>
            <li>Monkey-patching: Adding more methods to the prototype of JavaScript’s built-in objects to add more functionality</li>
            <li>The current consensus in the JS community is that this shouldn't be done, so you should avoid monkey-patching any of the built-in object constructor prototypes, unless you have a very good reason</li>
            <li>Basic mixin functionality is provided by the Object.assign() method</li>
          </ul>
        </p>
        <p>Mixins
          <ul>
            <li>A mixin is a way of adding properties and methods of some objects to another object without using inheritance</li>
            <li>It allows more complex objects to be created by ‘mixing’ basic objects together</li>

          </ul>
        </p>
        <p>Chaining Functions
          <ul>
            <li>If a method returns this, its methods can be chained together to form a sequence of method calls that are called one after the other</li>
          </ul>
        </p>
      </section>

      <section class="notes odd">
        <h2>Notes</h2>
        <hr>
        <p class="title">Chapter 15: Modern JavasScript</p>
          
        <p>
          <ul>
            <li>A module is a self-contained piece of code that provides functions and methods that can then be used in other files and by other modules. This helps to keep code organized in separate, reusable files, which improves code maintainability.</li>
            <li>The code in a module should have a single purpose, and group together functions with distinct functionality.</li>
            <li>Keeping code modular helps to make it more loosely coupled and interchangeable, meaning you can easily swap one module for another without affecting other parts of a project.</li>
            <li>Coupling: refers to how dependent certain elements or modules of code are on each other.</li>
          </ul>
        </p>
        <p>Coupling
          <ul>
            <li>Refers to how dependent certain elements or modules of code are on each other.</li>
            <li>Tightly coupled code means if one piece of code relies on the other to run</li>
            <li>Loosely coupled code means if one piece of code can be easily substituted by another without affecting the final outcome.</li>
            <li>
              <ol>
                <li>All code in modules is always in strict mode without the need for 'use strict' and there is no way to opt out of this.</li>
                <li>A module has its own global scope, so any variables created in the top-level of a module can only be accessed within that module.</li>
                <li>The value of this in the top level of a module is undefined, rather than the global object.</li>
                <li>You can't use HTML-style comments in modules (although this isn't very common in any JavaScript program these days).</li>
              </ol>
            </li>
          </ul>
        </p>
        <p>NODE.JS MODULES
          <ul>
            <li>Node.js had already implemented modules before they were introduced in ES6, and used a slightly different notation called Common JS modules</li>
          </ul>
        </p>      
      </section>

      <section class="questions">
        <h2>Questions</h2>
        <hr>
        <p>
        <ol>
          <li>Are constructors always required when making a Class?</li>
          <li>Are there some prototype methods that cannot be changed, or can all prototype methods be overridden to some degree?</li>
        </ol>
      </p>
      </section>
    </div>
    <footer>
      &COPY;<span id="#year"></span> Jay Johnson | WDD330 | BYU-I
    </footer>
    </div>
    <script src="../js/main.js"></script>
  </body>
</html>